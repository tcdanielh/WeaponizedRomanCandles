// Each #kernel tells which function to compile; you can have many kernels


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture3D<float4> Prev;
RWTexture3D<float4> Result;

RWTexture3D<float4> Temperature;

float4 position, size;

float time, radius, power, force, dt;

float4 gridMin;
float cellSize;


#pragma kernel AddDensity
[numthreads(8,8,8)]
void AddDensity (uint3 id : SV_DispatchThreadID)
{
  // TODO: insert actual code here!

    float3 pos = id.xyz - position.xyz;
    
    //float3 pos = id/(size.xyz-1.0f) - position.xyz;
   
	float magnitude = pos.x*pos.x + pos.y*pos.y + pos.z*pos.z;
    //float distance = sqrt(magnitude);
     /*
    if(magnitude < radius) {
        Result[id.xyz] = Prev[id] + float4(100.0, 0.0, 0.0, 0.0);
    } else {
        Result[id.xyz] = Prev[id];
    }*/
    
    /*
    //Result[id.xyz] = max(radius - distance, 0.0f) * 100;
	
	//float threshold = 15.0f;
	
    float quantity = max(radius - distance, 0.0);
    //Result[id.xyz] = vector4(quantity, 0.0, 0.0, 0.0);
    */
    
    float radius2 = radius*radius;
    float quantity = exp(-magnitude/radius2) * power;
    Result[id.xyz] = Prev[id.xyz] + float4(quantity, 0.0, 0.0, 0.0);///quantity;
    
}

#pragma kernel ApplyForce
[numthreads(8,8,8)]
void ApplyForce (uint3 id : SV_DispatchThreadID)
{
    
    //float3 c = force * dt * exp(pow(id/(size.xyz-1.0f) - position.xyz, 2.0f) / radius);
    //Result[id] = Prev[id] + (float4(c, 0.0) + 128.0f) / 255.0f;
    

    //8 bits to store per channel 0 -> 255, values are mapped from 0 to 1
    //input velocity is from [-128, 127]
    //convert to [0, 255] by adding 128 then divide by 255 to get [0, 1]
    Result[id] = Prev[id] + (float4(2.0f, 0.0f, 0.0f, 0) + 128.0f) / 255.0f;
    //Result[id] = Prev[id] + (float4((sin(id.y) + 2), 0, 0 ,0 ) + 128.0f) / 255.0f;
}

struct Ejecta {
    float3 pos;
    float3 v;
    float4 color;
    int landed;
};
RWStructuredBuffer<Ejecta> Ejectas;

int3 localPos(float3 pos) {
    float3 relativePos = pos - gridMin.xyz;
    int3 posI = int3(floor(relativePos / cellSize));
    return posI;
}

#pragma kernel CreateTrails
[numthreads(10, 1, 1)]
void CreateTrails(uint3 id : SV_DispatchThreadID)
{
    Ejecta e = Ejectas[id.x];
    if (e.pos.y < 0.1) return;
    int3 b = localPos(e.pos);
    for (int i = b.x - 10; i <= b.x + 10; i++) {
        for (int j = b.y - 10; j <= b.y + 10; j++) {
            for (int k = b.z - 10; k <= b.z + 10; k++) {
                int3 p = int3(i, j, k); 
                float3 pos = p - b;
                float magnitude = pos.x * pos.x + pos.y * pos.y + pos.z * pos.z;
                float radius2 = radius * radius;
                float quantity = exp(-magnitude / radius2) * power;
                Result[p] = Prev[p] + float4(quantity, 0.0, 0.0, 0.0);///quantity;
                //Temperature[p] = float4(quantity, 0.0, 0.0, 0.0);
                //Result[p] = Prev[p] + float4(power, 0.0, 0.0, 0.0);///quantity;
                //Result[p] = float4(1, 1, 1, 1);
            }
        }
    }
}

